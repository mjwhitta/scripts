#!/usr/bin/env ruby

require "io/wait"
require "optparse"
require "pathname"

class Exit
    GOOD = 0
    INVALID_OPTION = 1
    INVALID_ARGUMENT = 2
    MISSING_ARGUMENT = 3
    EXTRA_ARGUMENTS = 4
    EXCEPTION = 5
    AMBIGUOUS_ARGUMENT = 6
end

def decrement_by(key, char)
    return increment_by(26 - key, char)
end

def increment_by(key, char)
    key.times do
        case char
        when /[A-Ya-y]/
            char.next!
        when "Z"
            char = "A"
        when "z"
            char = "a"
        end
    end
    return char
end

def parse(args)
    options = Hash.new
    options["action"] = "encrypt"
    options["verbose"] = false

    info = "Encrypt or decrypte using Caesar Cipher"

    parser = OptionParser.new do |opts|
        opts.summary_width = 32

        opts.banner =
            "Usage: #{File.basename($0)} [OPTIONS] <key> <file>"

        opts.on("")

        info.scan(/\S.{0,80}\S(?=\s|$)|\S+/).each do |line|
            opts.on("#{line}")
        end

        opts.on("", "OPTIONS")

        opts.on("-d", "--decrypt", "Decrypt ciphertext)") do
            options["action"] = "decrypt"
        end

        opts.on("-e", "--encrypt", "Encrypt plaintext (default)") do
            options["action"] = "encrypt"
        end

        opts.on("-h", "--help", "Display this help message") do
            puts opts
            exit Exit::GOOD
        end

        opts.on(
            "-v",
            "--verbose",
            "Show backtrace when error occurs"
        ) do
            options["verbose"] = true
        end
    end

    begin
        parser.parse!(args)
    rescue OptionParser::InvalidOption => e
        puts e.message
        puts parser
        exit Exit::INVALID_OPTION
    rescue OptionParser::InvalidArgument => e
        puts e.message
        puts parser
        exit Exit::INVALID_ARGUMENT
    rescue OptionParser::MissingArgument => e
        puts e.message
        puts parser
        exit Exit::MISSING_ARGUMENT
    rescue OptionParser::AmbiguousOption => e
        puts e.message
        puts parser
        exit Exit::AMBIGUOUS_ARGUMENT
    end

    if (args.empty?)
        puts parser
        exit Exit::MISSING_ARGUMENT
    elsif (args.length != 2)
        puts parser
        exit Exit::EXTRA_ARGUMENTS
    end

    options["key"] = args[0].to_i
    options["file"] = args[1]

    return options
end

def process(action, key, filename)
    File.open(filename, "r") do |f|
        f.readlines.each do |line|
            line.chomp!
            line.chars.each do |char|
                case char
                when /[A-Za-z]/
                    case action
                    when "decrypt"
                        print decrement_by(key, char)
                    when "encrypt"
                        print increment_by(key, char)
                    end
                else
                    print char
                end
            end
            puts
        end
    end
    # case action
    # when "decrypt"
    # when "encrypt"
    # end
end

begin
    options = parse(ARGV)
rescue Interrupt
    # Exit gracefully on ^C
    exit Exit::GOOD
end

begin
    filename = Pathname.new(options["file"]).expand_path
    if (filename.exist?)
        process(options["action"], options["key"], filename)
    else
        puts "#{options["file"]} does not exist"
    end
rescue Interrupt
    # Exit gracefully on ^C
rescue Errno::EPIPE
    # Do nothing. This can happen if piping to another program such as
    # less. Usually if less is closed before we're done with STDOUT.
rescue Exception => e
    $stderr.puts [
        "Oops! Looks like an error has occured! Maybe the message",
        "below will help. If not,"
    ].join(" ")
    $stderr.puts "you can use the --verbose flag to get a backtrace."
    $stderr.puts

    $stderr.puts e.message
    if (options["verbose"])
        e.backtrace.each do |line|
            $stderr.puts line
        end
    end
    exit Exit::EXCEPTION
end
exit Exit::GOOD
