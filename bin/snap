#!/usr/bin/env bash
# A script for adding aero style window snapping to Linux.
# by Miles Whittaker <mjwhitta@gmail.com>
#
# --------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2018 Miles Whittaker
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# --------------------------------------------------------------------

### Helpers begin
check_deps() {
    for d in "${deps[@]}"; do
        [[ -n $(command -v "$d") ]] || errx 128 "$d is not installed"
    done; unset d
}
err() { echo -e "${color:+\e[31m}[!] $*\e[0m"; }
errx() { err "${*:2}"; unlock; exit "$1"; }
good() { echo -e "${color:+\e[32m}[+] $*\e[0m"; }
info() { echo -e "${color:+\e[37m}[*] $*\e[0m"; }
long_opt() {
    local arg shift="0"
    case "$1" in
        "--"*"="*) arg="${1#*=}"; [[ -n $arg ]] || usage 127 ;;
        *) shift="1"; shift; [[ $# -gt 0 ]] || usage 127; arg="$1" ;;
    esac
    echo "$arg"
    return $shift
}
subinfo() { echo -e "${color:+\e[36m}[=] $*\e[0m"; }
warn() { echo -e "${color:+\e[33m}[-] $*\e[0m"; }
### Helpers end

get_previous() { grep -oPs "^$1\s+\K.+" "$snap_hist"; }

lock() { touch "$snap_hist.lock"; locked="true"; }

perform_snap() {
    local id="$1"
    local previous="${2:-null}"
    local new="$3"

    local h
    local w
    local x
    local y

    # Remove any maximized attributes
    wmctrl -b remove,maximized_vert,maximized_horz -ir "$id"

    case "$previous" in
        "$new" )
            # Calculate snap values
            x="$((hhw + (padding / 2)))"
            y="$((hhh + (padding / 2) + offset))"
            w="$((hw - (3 * padding / 2)))"
            h="$((hh - (3 * padding / 2) - frame))"

            # Snap
            wmctrl -e "0,$x,$y,$w,$h" -ir "$id"

            # Remove history file if empty
            find "$snap_hist" -empty -delete
            ;;
        *)
            # Calculate snap values
            case "$new" in
                "bottom")
                    x="$padding"
                    y="$((hh + (padding / 2) + offset))"
                    w="$((width - (2 * padding)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "bottom-left")
                    x="$padding"
                    y="$((hh + (padding / 2) + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "bottom-right")
                    x="$((hw + (padding / 2)))"
                    y="$((hh + (padding /  2) + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "center")
                    x="$((hhw + (padding / 2)))"
                    y="$((padding + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((height - (2 * padding) - frame))"
                    ;;
                "left")
                    x="$padding"
                    y="$((padding + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((height - (2 * padding) - frame))"
                    ;;
                "max")
                    x="$padding"
                    y="$((padding + offset))"
                    w="$((width - (2 * padding)))"
                    h="$((height - (2 * padding) - frame))"
                    ;;
                "min")
                    x="$((hhw + (padding / 2)))"
                    y="$((hhh + (padding / 2) + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "right")
                    x="$((hw + (padding / 2)))"
                    y="$((padding + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((height - (2 * padding) - frame))"
                    ;;
                "top")
                    x="$padding"
                    y="$((padding + offset))"
                    w="$((width - (2 * padding)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "top-left")
                    x="$padding"
                    y="$((padding + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
                "top-right")
                    x="$((hw + (padding / 2)))"
                    y="$((padding + offset))"
                    w="$((hw - (3 * padding / 2)))"
                    h="$((hh - (3 * padding / 2) - frame))"
                    ;;
            esac

            # Snap
            wmctrl -e "0,$x,$y,$w,$h" -ir "$id"

            # Set any needed maximized attributes
            # if [[ $padding -eq 0 ]]; then <-- handled by case below
            case "$padding$new" in
                "0bottom") wmctrl -b add,maximized_horz -ir "$id" ;;
                "0center") wmctrl -b add,maximized_vert -ir "$id" ;;
                "0left") wmctrl -b add,maximized_vert -ir "$id" ;;
                "0max")
                        wmctrl -b add,maximized_vert,maximized_horz \
                            -ir "$id"
                    ;;
                *"min") wmctrl -b add,hidden -ir "$id" ;;
                "0right") wmctrl -b add,maximized_vert -ir "$id" ;;
                "0top") wmctrl -b add,maximized_horz -ir "$id" ;;
            esac

            # Create new entry
            [[ $new == "min" ]] || echo "$id $new" >>"$snap_hist"
            ;;
    esac
}

replay_snaps() {
    local id
    local previous

    rm -f "$snap_replay"
    mv -f "$snap_hist" "$snap_replay"

    while read -r id previous; do
        perform_snap "$id" "" "$previous"
    done <"$snap_replay"; unset id previous

    rm -f "$snap_replay"
}

snap_current_window() {
    # Get unique ID
    local wid="$(xdotool getactivewindow)"
    local pid="$(xdotool getwindowpid "$wid")"
    [[ -n $pid ]] || errx 4 "Could not determine PID"
    local id="$wid-$pid"
    [[ -n $id ]] || errx 5 "Could not determine window identifiers"

    # Check history file for entry and see if matches current location
    local previous="$(get_previous "$id")"

    # Remove old entry and any blank lines
    sed -i -r "/^$id\s|^\s*$/d" "$snap_hist"

    perform_snap "$id" "$previous" "$snap_option"
}

unlock() { [[ -z $locked ]] || rm -f "$snap_hist.lock"; }

usage() {
    cat <<EOF
Usage: ${0##*/} [OPTIONS] [width] [height]

Simple window management tool.

Options:
    -b, --bottom          Snap active window to bottom
    --bottom-left         Snap active window to bottom-left
    --bottom-right        Snap active window to bottom-right
    -c, --center          Snap active window to center
    -f, --frame=FRAME     Specify frame size (default: $frame)
    -h, --help            Display this help message
    -l, --left            Snap active window to left
    -m, --max             Maximize window
    -n, --min             Minimize widow
    --no-color            Disable colorized output
    -o, --offset=SIZE     Specify offset from top (default: $offset)
    -p, --padding=SIZE    Specify padding (default: $padding)
    --replay              Replay all snaps with current geometry
                          (default)
    -r, --right           Snap active window to right
    -t, --top             Snap active window to top
    --top-left            Snap active window to top-left
    --top-right           Snap active window to top-right

EOF
    exit "$1"
}

wait_for_lock() {
    for _ in {1..20}; do
        [[ -f "$snap_hist.lock" ]] || break
        sleep 0.1
    done
    [[ ! -f "$snap_hist.lock" ]] || errx 3 "Lock file exists"
}

declare -a args deps
unset help locked
color="true"
deps+=("wmctrl")
deps+=("xdotool")
deps+=("xrandr")
frame="20"
offset="0"
padding="0"
snap_hist="/tmp/snap.hist"
snap_option="replay"
snap_replay="/tmp/snap.replay"

# Check for missing dependencies
check_deps

# Parse command line options
while [[ $# -gt 0 ]]; do
    case "$1" in
        "--") shift && args+=("$@") && break ;;
        "-b"|"--bottom") snap_option="bottom" ;;
        "--bottom-left") snap_option="bottom-left" ;;
        "--bottom-right") snap_option="bottom-right" ;;
        "-c"|"--center") snap_option="center" ;;
        "-f"|"--frame"*) frame="$(long_opt "$@")" || shift ;;
        "-h"|"--help") help="true" ;;
        "-l"|"--left") snap_option="left" ;;
        "-m"|"--max") snap_option="max" ;;
        "-n"|"--min") snap_option="min" ;;
        "--nocolor") unset color ;;
        "-o"|"--offset"*) offset="$(long_opt "$@")" || shift ;;
        "-p"|"--padding"*) padding="$(long_opt "$@")" || shift ;;
        "--replay") snap_option="replay" ;;
        "-r"|"--right") snap_option="right" ;;
        "-t"|"--top") snap_option="top" ;;
        "--top-left") snap_option="top-left" ;;
        "--top-right") snap_option="top-right" ;;
        *) args+=("$1") ;;
    esac
    shift
done
[[ ${#args[@]} -eq 0 ]] || set -- "${args[@]}"

# Check for valid params
[[ -z $help ]] || usage 0
[[ $# -eq 0 ]] || [[ $# -eq 2 ]] || usage 1

if [[ $# -eq 2 ]]; then
    height="$2"
    width="$1"
else
    geometry="$(xrandr | grep -oPs "current \K[^,]+")"
    [[ -n $geometry ]] || errx 2 "Could not determine geometry"
    height="${geometry/*x /}"
    width="${geometry/ x*/}"
fi

((height -= offset))
hw="$((width / 2))"
hhw="$((width / 4))"
hh="$((height / 2))"
hhh="$((height / 4))"

wait_for_lock
lock

case "$snap_option" in
    "replay") replay_snaps ;;
    *) snap_current_window ;;
esac

unlock
